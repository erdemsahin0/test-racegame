<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Nitro Lane Rush</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
<div id="game-container">
    <div class="loading">Loading Nitro Lane Rush...</div>
</div>
<script>
// Asset manager with safe texture creation
class AssetManager {
    static createTextures(scene) {
        // Create particle texture safely
        if (!scene.textures.exists('particle')) {
            const g = scene.add.graphics();
            g.fillStyle(0xFFFFFF);
            g.fillCircle(2, 2, 2);
            g.generateTexture('particle', 4, 4);
            g.destroy();
        }
        
        // Create power-up texture safely
        if (!scene.textures.exists('powerup_shield')) {
            const g = scene.add.graphics();
            g.fillStyle(0x0066FF);
            g.fillCircle(0, 0, 15);
            g.fillStyle(0xFFFFFF);
            g.fillCircle(0, 0, 10);
            g.fillStyle(0x0066FF);
            g.fillCircle(0, 0, 5);
            g.generateTexture('powerup_shield', 30, 30);
            g.destroy();
        }
    }
}

// START SCENE
class StartScene extends Phaser.Scene {
    constructor() {
        super('StartScene');
    }
    
    create() {
        document.querySelector('.loading').style.display = 'none';
        
        const title = this.add.text(400, 150, 'Nitro Lane Rush', { 
            fontSize: '48px', fill: '#fff', fontStyle: 'bold',
            stroke: '#FF6B00', strokeThickness: 3
        }).setOrigin(0.5);
        
        title.setScale(0);
        this.tweens.add({ targets: title, scale: 1, duration: 800, ease: 'Back.easeOut', delay: 200 });

        const startText = this.add.text(400, 300, 'Press SPACE or Tap to Start', { 
            fontSize: '24px', fill: '#00FF88', fontStyle: 'bold'
        }).setOrigin(0.5);
        
        this.tweens.add({ targets: startText, alpha: 0.3, duration: 1000, 
            ease: 'Sine.easeInOut', yoyo: true, repeat: -1 });

        const instructions = this.add.text(400, 350, 'Use Arrow Keys or Drag to Move', { 
            fontSize: '18px', fill: '#ccc' 
        }).setOrigin(0.5);
        
        instructions.setX(-200);
        this.tweens.add({ targets: instructions, x: 400, duration: 1000, 
            ease: 'Power2.easeOut', delay: 500 });

        const highScore = localStorage.getItem('nitroLaneRushHighScore') || 0;
        this.add.text(400, 380, `High Score: ${highScore}`, { 
            fontSize: '16px', fill: '#FFD700', fontStyle: 'bold'
        }).setOrigin(0.5);

        this.createSimpleBackground();
        
        this.game.canvas.setAttribute('tabindex', '0');
        this.game.canvas.focus();
        
        this.input.keyboard.once('keydown-SPACE', () => this.startGame());
        this.input.on('pointerdown', () => this.startGame());
    }

    createSimpleBackground() {
        for (let i = 0; i < 2; i++) {
            const line = this.add.rectangle(200 + i * 300, -50, 4, 100, 0x444444);
            this.tweens.add({ targets: line, y: 700, duration: 2500, 
                ease: 'Linear', repeat: -1, delay: i * 500 });
        }
    }

    startGame() {
        this.scene.start('GameScene');
    }
}

// GAME SCENE WITHOUT NITRO - HARDER GAMEPLAY WITH ROADBLOCKS AND MUTE BUTTON
class GameScene extends Phaser.Scene {
    constructor() {
        super('GameScene');
        this.resetGameState();
    }
    
    resetGameState() {
        this.playerSpeed = 300;
        this.isDragging = false;
        this.score = 0;
        this.roadSpeed = 4;
        this.enemySpeed = 150;
        this.spawnDelay = 1500;
        this.lives = 3;
        this.isInvincible = false;
        this.policeSpeed = 100;
        this.currentTrackIndex = 0;
        this.streak = 0;
        this.comboMultiplier = 1;
        this.comboTimer = 0;
        this.isPaused = false;
        this.musicVolume = 0.5;
        this.sfxVolume = 0.7;
        this.isMuted = false;
        this.difficultyLevel = 1;
        this.roadblockFrequency = 4000; // Initial roadblock spawn delay
        
        // Minimal pools for performance
        this.enemyCarPool = [];
        this.policeCarPool = [];
        this.roadblockPool = [];
        this.maxPoolSize = 10;
        
        // Effect management
        this.activeEffects = [];
        this.pauseMenu = null;
        this.muteButton = null;
    }

    preload() {
        document.querySelector('.loading').style.display = 'block';
        
        // Load assets
        this.load.image('road', 'assets/road.png');
        this.load.image('player_car_hero', 'assets/player_car_hero.png');
        this.load.image('enemy_car_green', 'assets/enemy_car_green.png');
        this.load.image('enemy_car_yellow', 'assets/enemy_car_yellow.png');
        this.load.image('enemy_car_blue_sky', 'assets/enemy_car_blue_sky.png');
        this.load.image('enemy_car_police', 'assets/enemy_car_police.png');
        this.load.image('obstacle_roadblock_a', 'assets/obstacle_roadblock_a.png');

        this.load.audio('music_1', 'assets/music_1.mp3');
        this.load.audio('music_2', 'assets/music_2.mp3');
        this.load.audio('music_3', 'assets/music_3.mp3');
        this.load.audio('music_4', 'assets/music_4.mp3');
        this.load.audio('sfx_crash', 'assets/crash.mp3');
        this.load.audio('sfx_powerup', 'assets/powerup.mp3');
        
        this.load.once('complete', () => {
            AssetManager.createTextures(this);
            document.querySelector('.loading').style.display = 'none';
        });
    }

    create() {
        this.resetGameState();
        
        // Road
        this.road = this.add.tileSprite(400, 300, 800, 600, 'road');

        // Player Car
        this.car = this.physics.add.sprite(400, 500, 'player_car_hero');
        this.car.setCollideWorldBounds(true);
        this.car.body.setSize(45, 130);
        this.car.setInteractive();
        
        // Input
        this.input.setDraggable(this.car);
        this.input.on('dragstart', () => { this.isDragging = true; });
        this.input.on('drag', (pointer, gameObject, dragX, dragY) => {
            const clampedX = Phaser.Math.Clamp(dragX, 120, 680);
            const clampedY = Phaser.Math.Clamp(dragY, 50, 550);
            gameObject.setPosition(clampedX, clampedY);
        });
        this.input.on('dragend', () => { this.isDragging = false; });
        
        // Music
        this.sound.stopAll();
        this.musicPlaylist = ['music_1', 'music_2', 'music_3', 'music_4'];
        this.playNextTrack();

        // Object groups
        this.enemyCars = this.physics.add.group();
        this.policeCars = this.physics.add.group();
        this.roadblocks = this.physics.add.group();
        
        this.initializeMinimalPools();
        
        // Timers
        this.spawnTimer = this.time.addEvent({ delay: this.spawnDelay, 
            callback: this.spawnEnemyCar, callbackScope: this, loop: true });
        this.policeSpawnTimer = this.time.addEvent({ delay: 8000, 
            callback: this.spawnPoliceCar, callbackScope: this, loop: true });
        this.roadblockSpawnTimer = this.time.addEvent({ delay: this.roadblockFrequency, 
            callback: this.spawnRoadblock, callbackScope: this, loop: true, paused: true });

        // Collisions
        this.physics.add.overlap(this.car, this.enemyCars, this.hitEnemy, null, this);
        this.physics.add.overlap(this.car, this.policeCars, this.hitEnemy, null, this);
        this.physics.add.overlap(this.car, this.roadblocks, this.hitRoadblock, null, this);
        
        // UI - IMPROVED LAYOUT
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Top UI - separated to avoid overlap
        this.scoreText = this.add.text(16, 16, 'Score: 0', { 
            fontSize: '32px', fill: '#fff', fontStyle: 'bold',
            stroke: '#000', strokeThickness: 2
        });
        
        // Lives on the left
        this.livesText = this.add.text(16, 56, 'Lives: 3', { 
            fontSize: '32px', fill: '#fff', fontStyle: 'bold',
            stroke: '#000', strokeThickness: 2
        });
        
        // Pause button on the far right
        this.pauseButton = this.add.text(780, 16, '||', { 
            fontSize: '28px', 
            fill: '#fff',
            fontStyle: 'bold',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            padding: { left: 12, right: 12, top: 8, bottom: 8 }
        }).setOrigin(1, 0);
        this.pauseButton.setInteractive();
        this.pauseButton.on('pointerdown', () => this.togglePause());

        // Mute button below pause button
        this.muteButton = this.add.text(780, 60, 'ðŸ”‡', { 
            fontSize: '24px', 
            fill: '#fff',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            padding: { left: 10, right: 10, top: 5, bottom: 5 }
        }).setOrigin(1, 0);
        this.muteButton.setInteractive();
        this.muteButton.on('pointerdown', () => this.toggleMute());

        // Particle systems (safe versions)
        this.createSafeParticles();
        
        this.scoreTimer = this.time.addEvent({ delay: 100, 
            callback: this.updateScore, callbackScope: this, loop: true });
    }

    createSafeParticles() {
        // Exhaust particles (limited)
        this.exhaustEmitter = this.add.particles(0, 0, 'particle', {
            speed: { min: 20, max: 40 },
            scale: { start: 0.3, end: 0 },
            alpha: { start: 0.6, end: 0 },
            lifespan: 300,
            frequency: 200,
            tint: 0x666666,
            maxParticles: 20
        });
        this.exhaustEmitter.startFollow(this.car, 0, 30);
    }

    initializeMinimalPools() {
        const carTypes = ['enemy_car_green', 'enemy_car_yellow', 'enemy_car_blue_sky'];
        
        for (let i = 0; i < this.maxPoolSize; i++) {
            const carType = carTypes[i % carTypes.length];
            const car = this.physics.add.sprite(-100, -100, carType);
            car.setActive(false).setVisible(false);
            car.body.setSize(45, 100);
            this.enemyCarPool.push(car);
            this.enemyCars.add(car);
        }
        
        for (let i = 0; i < 5; i++) {
            const car = this.physics.add.sprite(-100, -100, 'enemy_car_police');
            car.setActive(false).setVisible(false);
            car.body.setSize(50, 120);
            car.setData('isChasing', false);
            this.policeCarPool.push(car);
            this.policeCars.add(car);
        }
        
        for (let i = 0; i < 8; i++) {
            const roadblock = this.physics.add.sprite(-100, -100, 'obstacle_roadblock_a');
            roadblock.setActive(false).setVisible(false);
            roadblock.setScale(2);
            roadblock.body.setSize(roadblock.width * 0.6, roadblock.height * 0.6); // Smaller hitbox
            roadblock.setImmovable(true); // Makes roadblocks immovable
            this.roadblockPool.push(roadblock);
            this.roadblocks.add(roadblock);
        }
    }

    playNextTrack() {
        if (this.currentTrackIndex >= this.musicPlaylist.length) {
            this.currentTrackIndex = 0;
        }
        const trackKey = this.musicPlaylist[this.currentTrackIndex];
        this.currentMusic = this.sound.add(trackKey, { volume: this.isMuted ? 0 : this.musicVolume });
        this.currentMusic.play();
        this.currentTrackIndex++;
        this.currentMusic.on('complete', this.playNextTrack, this);
    }

    updateScore() {
        this.score += 1 * this.comboMultiplier;
        this.scoreText.setText('Score: ' + this.score);
        
        if (this.comboTimer > 0) {
            this.comboTimer--;
            if (this.comboTimer <= 0) {
                this.comboMultiplier = 1;
            }
        }
        
        // Increase difficulty based on score
        if (this.score > 0 && this.score % 200 === 0) {
            this.difficultyLevel++;
            this.increaseDifficulty();
        }
        
        // Activate roadblocks at score 500
        if (this.score >= 500 && this.roadblockSpawnTimer.paused) {
            this.roadblockSpawnTimer.paused = false;
            // Show roadblock warning
            const warningText = this.add.text(400, 300, 'ROADBLOCKS AHEAD!', {
                fontSize: '36px',
                fill: '#FF0000',
                fontStyle: 'bold',
                stroke: '#000',
                strokeThickness: 3
            }).setOrigin(0.5);

            this.tweens.add({
                targets: warningText,
                alpha: 0,
                y: 200,
                duration: 2000,
                ease: 'Power2.easeOut',
                onComplete: () => warningText.destroy()
            });
        }
    }
    
    increaseDifficulty() {
        // Make everything faster and more challenging
        this.roadSpeed = Math.min(this.roadSpeed + 0.5, 12);
        this.enemySpeed = Math.min(this.enemySpeed + 20, 400);
        this.policeSpeed = Math.min(this.policeSpeed + 25, 300);
        
        // Decrease spawn delays
        this.spawnTimer.delay = Math.max(this.spawnTimer.delay * 0.92, 300);
        this.policeSpawnTimer.delay = Math.max(this.policeSpawnTimer.delay * 0.95, 2000);
        
        // Increase roadblock frequency
        if (!this.roadblockSpawnTimer.paused) {
            this.roadblockFrequency = Math.max(this.roadblockFrequency * 0.85, 800);
            this.roadblockSpawnTimer.delay = this.roadblockFrequency;
        }
        
        // Visual feedback for difficulty increase
        const difficultyText = this.add.text(400, 300, `LEVEL ${this.difficultyLevel}!`, {
            fontSize: '48px',
            fill: '#FF6600',
            fontStyle: 'bold',
            stroke: '#000',
            strokeThickness: 3
        }).setOrigin(0.5);
        
        this.tweens.add({
            targets: difficultyText,
            alpha: 0,
            y: 200,
            duration: 1500,
            ease: 'Power2.easeOut',
            onComplete: () => difficultyText.destroy()
        });
    }
    
    spawnRoadblock() {
        const roadblock = this.getFromPool(this.roadblockPool, (obj) => {
            const x = Phaser.Math.Between(120, 680);
            obj.setPosition(x, -50);
            obj.setScale(2);
            // Fixed position - only moves with road speed
            obj.setVelocityY(this.roadSpeed * 60); // Sync with road movement
            obj.setImmovable(true); // Makes the roadblock immovable on collision
        });
    }
    
    spawnEnemyCar() {
        const enemyCar = this.getFromPool(this.enemyCarPool, (car) => {
            const x = Phaser.Math.Between(120, 680);
            car.setPosition(x, -50);
            car.setVelocityY(this.enemySpeed);
        });
    }

    spawnPoliceCar() {
        const policeCar = this.getFromPool(this.policeCarPool, (car) => {
            const side = Phaser.Math.RND.pick(['left', 'right']);
            const yPos = Phaser.Math.RND.pick([150, 450]);
            let startX = side === 'left' ? -50 : 850;
            
            car.setPosition(startX, yPos);
            car.setData('isChasing', false);
            car.setVelocityX(side === 'left' ? 100 : -100);
            
            this.time.delayedCall(800, () => {
                if (car.active) {
                    const targetX = side === 'left' ? 160 : 640;
                    car.setVelocityX(0);
                    car.setVelocityY(this.enemySpeed * 0.9);
                    car.setData('isChasing', true);
                }
            });
        });
    }

    hitEnemy(player, enemyCar) {
        if (this.isInvincible) {
            this.returnToPool(enemyCar);
            return;
        }
        
        if (!this.isMuted) {
            this.safePlaySound('sfx_crash');
        }
        this.createCrashEffect(enemyCar.x, enemyCar.y);
        this.returnToPool(enemyCar);
        
        this.lives--;
        this.livesText.setText('Lives: ' + this.lives);
        
        if (this.lives <= 0) {
            this.gameOver();
        } else {
            this.isInvincible = true;
            this.time.delayedCall(1500, () => {
                this.isInvincible = false;
            });
        }
    }
    
    // SAFE CRASH EFFECTS WITH PROPER CLEANUP
    createCrashEffect(x, y) {
        // Limit number of active effects
        if (this.activeEffects.length > 5) {
            // Remove oldest effect
            const oldEffect = this.activeEffects.shift();
            if (oldEffect && oldEffect.active) {
                oldEffect.destroy();
            }
        }
        
        // Create explosion particles
        const explosion = this.add.particles(x, y, 'particle', {
            speed: { min: 100, max: 300 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 500,
            quantity: 10,
            tint: [0xFF6600, 0xFF0000, 0xFFFF00],
            maxParticles: 15
        });
        
        // Store reference and auto-cleanup
        this.activeEffects.push(explosion);
        this.time.delayedCall(500, () => {
            const index = this.activeEffects.indexOf(explosion);
            if (index > -1) {
                this.activeEffects.splice(index, 1);
            }
            if (explosion.active) {
                explosion.destroy();
            }
        });
        
        // Screen shake effect
        this.cameras.main.shake(200, 0.01);
    }

    // PAUSE/RESUME FUNCTIONALITY
    togglePause() {
        this.isPaused = !this.isPaused;
        
        if (this.isPaused) {
            this.pauseGame();
        } else {
            this.resumeGame();
        }
    }
    
    pauseGame() {
        // Pause physics
        this.physics.pause();
        
        // Pause timers
        if (this.spawnTimer) this.spawnTimer.paused = true;
        if (this.policeSpawnTimer) this.policeSpawnTimer.paused = true;
        this.roadblockSpawnTimer.paused = true;
        if (this.scoreTimer) this.scoreTimer.paused = true;
        
        // Pause music
        if (this.currentMusic) {
            this.currentMusic.pause();
        }
        
        // Stop particle emitters
        if (this.exhaustEmitter) this.exhaustEmitter.stop();
        
        // Show pause menu
        this.createPauseMenu();
    }
    
    resumeGame() {
        // Resume physics
        this.physics.resume();
        
        // Resume timers
        if (this.spawnTimer) this.spawnTimer.paused = false;
        if (this.policeSpawnTimer) this.policeSpawnTimer.paused = false;
        if (this.roadblockSpawnTimer) this.roadblockSpawnTimer.paused = false;
        if (this.scoreTimer) this.scoreTimer.paused = false;
        
        // Resume music
        if (this.currentMusic) {
            this.currentMusic.resume();
        }
        
        // Resume particle emitters
        if (this.exhaustEmitter) this.exhaustEmitter.start();
        
        // Hide pause menu
        if (this.pauseMenu) {
            this.pauseMenu.destroy();
            this.pauseMenu = null;
        }
    }
    
    // MUTE TOGGLE FUNCTIONALITY
    toggleMute() {
        this.isMuted = !this.isMuted;
        
        // Update button text
        this.muteButton.setText(this.isMuted ? 'ðŸ”ˆ' : 'ðŸ”‡');
        
        // Update music volume
        if (this.currentMusic) {
            this.currentMusic.setVolume(this.isMuted ? 0 : this.musicVolume);
        }
        
        // Update sound effects (they will be skipped when muted)
    }
    
    createPauseMenu() {
        // Create semi-transparent overlay
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.7);
        
        // Create pause menu container
        this.pauseMenu = this.add.container(400, 300);
        
        // Menu background
        const menuBg = this.add.rectangle(0, 0, 400, 300, 0x333333);
        menuBg.setStrokeStyle(2, 0xFFFFFF);
        
        // Title
        const title = this.add.text(0, -100, 'PAUSED', {
            fontSize: '36px',
            fill: '#FFFFFF',
            fontStyle: 'bold'
        }).setOrigin(0.5);
        
        // Resume button
        const resumeBtn = this.add.text(0, -30, 'Resume Game', {
            fontSize: '24px',
            fill: '#00FF88',
            backgroundColor: '#444',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5);
        resumeBtn.setInteractive();
        resumeBtn.on('pointerdown', () => this.togglePause());
        
        // Quit button
        const quitBtn = this.add.text(0, 30, 'Quit to Menu', {
            fontSize: '24px',
            fill: '#FF6600',
            backgroundColor: '#444',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5);
        quitBtn.setInteractive();
        quitBtn.on('pointerdown', () => {
            this.cleanupBeforeQuit();
            this.scene.start('StartScene');
        });
        
        // Add all elements to container
        this.pauseMenu.add([overlay, menuBg, title, resumeBtn, quitBtn]);
    }
    
    cleanupBeforeQuit() {
        // Stop all sounds
        try {
            if (this.currentMusic) this.currentMusic.stop();
        } catch (e) { /* silent fail */ }
        
        // Stop particle effects
        try {
            if (this.exhaustEmitter) this.exhaustEmitter.stop();
        } catch (e) { /* silent fail */ }
        
        // Cleanup active effects
        this.cleanupEffects();
        
        // Cleanup all objects
        this.cleanupAllObjects();
    }
    
    gameOver() {
        const highScore = localStorage.getItem('nitroLaneRushHighScore') || 0;
        if (this.score > highScore) {
            localStorage.setItem('nitroLaneRushHighScore', this.score);
        }
        
        this.cleanupBeforeQuit();
        
        this.time.delayedCall(1000, () => {
            this.scene.start('GameOverScene', { score: this.score });
        });
    }

    cleanupEffects() {
        // Clean up any remaining effects
        while (this.activeEffects.length > 0) {
            const effect = this.activeEffects.pop();
            if (effect && effect.active) {
                try { effect.destroy(); } catch (e) { /* silent fail */ }
            }
        }
    }

    cleanupAllObjects() {
        // Force destroy all active objects to prevent memory leaks
        [...this.enemyCars.children.entries].forEach(obj => {
            if (obj.active) {
                try { obj.destroy(); } catch (e) { /* silent fail */ }
            }
        });
        
        [...this.policeCars.children.entries].forEach(obj => {
            if (obj.active) {
                try { obj.destroy(); } catch (e) { /* silent fail */ }
            }
        });
        
        [...this.roadblocks.children.entries].forEach(obj => {
            if (obj.active) {
                try { obj.destroy(); } catch (e) { /* silent fail */ }
            }
        });
        
        try {
            if (this.spawnTimer) this.spawnTimer.remove(false);
            if (this.policeSpawnTimer) this.policeSpawnTimer.remove(false);
            if (this.roadblockSpawnTimer) this.roadblockSpawnTimer.remove(false);
            if (this.scoreTimer) this.scoreTimer.remove(false);
        } catch (e) { /* silent fail */ }
    }

    getFromPool(pool, resetCallback) {
        for (let obj of pool) {
            if (!obj.active) {
                obj.setActive(true).setVisible(true);
                resetCallback(obj);
                return obj;
            }
        }
        return null;
    }

    returnToPool(object) {
        if (!object) return;
        object.setActive(false).setVisible(false);
        object.body.setVelocity(0, 0);
        object.body.setAcceleration(0, 0);
        object.setPosition(-100, -100);
        object.setScale(1);
        object.setAlpha(1);
        if (object.setData) object.setData('isChasing', false);
    }
    
    update() {
        if (this.isPaused) return;
        
        if (!this.car || !this.car.body) return;
        
        this.road.tilePositionY -= this.roadSpeed;
        
        if (!this.isDragging) {
            this.car.body.setVelocity(0);
            
            let currentSpeed = this.playerSpeed;
            const acceleration = currentSpeed * 1.2;
            
            // Car tilt effect when turning
            if (this.cursors.left.isDown && this.car.x > 120) { 
                this.car.body.setVelocityX(-acceleration);
                // Tilt car to the left when turning left
                this.car.setRotation(-0.1);
            } else if (this.cursors.right.isDown && this.car.x < 680) { 
                this.car.body.setVelocityX(acceleration);
                // Tilt car to the right when turning right
                this.car.setRotation(0.1);
            } else {
                // Return to center rotation when not turning
                this.car.setRotation(0);
            }
            
            if (this.cursors.up.isDown && this.car.y > 50) { 
                this.car.body.setVelocityY(-acceleration);
            } else if (this.cursors.down.isDown && this.car.y < 550) { 
                this.car.body.setVelocityY(acceleration);
            }
        }

        this.cleanupOffscreenObjects();
        this.updatePoliceAI();
    }

    cleanupOffscreenObjects() {
        this.enemyCars.children.entries.forEach(car => {
            if (car.active && car.y > 650) this.returnToPool(car);
        });
        
        this.policeCars.children.entries.forEach(car => {
            if (car.active && car.y > 700) this.returnToPool(car);
        });
        
        this.roadblocks.children.entries.forEach(roadblock => {
            if (roadblock.active && roadblock.y > 650) {
                this.returnToPool(roadblock);
            }
        });
    }

    updatePoliceAI() {
        this.policeCars.children.entries.forEach(policeCar => {
            if (policeCar.active && policeCar.getData('isChasing')) {
                const dx = this.car.x - policeCar.x;
                const targetSpeed = this.policeSpeed * 0.8;
                
                if (Math.abs(dx) > 15) {
                    const acceleration = dx > 0 ? targetSpeed : -targetSpeed;
                    policeCar.body.setAccelerationX(acceleration);
                } else {
                    policeCar.body.setAccelerationX(0);
                }
            }
        });
    }
}

// GAME OVER SCENE
class GameOverScene extends Phaser.Scene {
    constructor() {
        super('GameOverScene');
    }
    
    init(data) {
        this.finalScore = data.score;
    }
    
    create() {
        document.querySelector('.loading').style.display = 'none';
        
        this.add.text(400, 200, 'GAME OVER', { 
            fontSize: '64px', fill: '#ff0000', fontStyle: 'bold',
            stroke: '#000', strokeThickness: 4
        }).setOrigin(0.5);
        
        this.add.text(400, 300, 'Your Score: ' + this.finalScore, { 
            fontSize: '32px', fill: '#fff'
        }).setOrigin(0.5);

        const highScore = localStorage.getItem('nitroLaneRushHighScore') || 0;
        if (this.finalScore >= highScore) {
            this.add.text(400, 350, 'NEW HIGH SCORE!', { 
                fontSize: '28px', fill: '#FFD700', fontStyle: 'bold'
            }).setOrigin(0.5);
        }

        this.add.text(400, 400, 'Tap or Press SPACE to Restart', { 
            fontSize: '24px', fill: '#fff'
        }).setOrigin(0.5);
        
        this.input.keyboard.once('keydown-SPACE', () => {
            this.scene.start('GameScene');
        });
        this.input.on('pointerdown', () => {
            this.scene.start('GameScene');
        });
    }
}

// PERFORMANCE OPTIMIZED CONFIG
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    backgroundColor: '#222',
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false,
            fps: 60
        }
    },
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    render: {
        antialias: false,
        pixelArt: true,
        roundPixels: true
    },
    scene: [StartScene, GameScene, GameOverScene]
};

// SAFE GAME INITIALIZATION
window.addEventListener('load', () => {
    try {
        window.game = new Phaser.Game(config);
    } catch (e) {
        console.error('Game initialization failed:', e);
        document.querySelector('.loading').innerHTML = 'Error loading game. Please refresh.';
    }
});

// CLEANUP ON UNLOAD
window.addEventListener('beforeunload', () => {
    if (window.game) {
        try {
            window.game.destroy(true);
        } catch (e) {
            console.error('Cleanup error:', e);
        }
    }
});
</script>
</body>
</html>
