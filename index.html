<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Nitro Lane Rush</title>
    <!-- Fixed the CDN link - removed extra spaces -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
<div id="game-container">
    <div class="loading">Loading Nitro Lane Rush...</div>
</div>
<script>
// SCENE 1: THE START SCREEN WITH ANIMATIONS
class StartScene extends Phaser.Scene {
    constructor() {
        super('StartScene');
    }
    
    create() {
        // Remove loading text
        document.querySelector('.loading').style.display = 'none';
        
        // Animated title with bounce effect
        const title = this.add.text(400, 150, 'Nitro Lane Rush', { 
            fontSize: '48px', 
            fill: '#fff',
            fontStyle: 'bold',
            stroke: '#FF6B00',
            strokeThickness: 3
        }).setOrigin(0.5);
        
        // Title animation - bounce in
        title.setScale(0);
        this.tweens.add({
            targets: title,
            scale: 1,
            duration: 800,
            ease: 'Back.easeOut',
            delay: 200
        });

        // Pulsing start text
        const startText = this.add.text(400, 300, 'Press SPACE or Tap to Start', { 
            fontSize: '24px', 
            fill: '#00FF88',
            fontStyle: 'bold'
        }).setOrigin(0.5);
        
        this.tweens.add({
            targets: startText,
            alpha: 0.3,
            duration: 1000,
            ease: 'Sine.easeInOut',
            yoyo: true,
            repeat: -1
        });

        // Instructions with slide-in effect
        const instructions = this.add.text(400, 350, 'Use Arrow Keys or Drag to Move', { 
            fontSize: '18px', 
            fill: '#ccc' 
        }).setOrigin(0.5);
        
        instructions.setX(-200);
        this.tweens.add({
            targets: instructions,
            x: 400,
            duration: 1000,
            ease: 'Power2.easeOut',
            delay: 500
        });

        // High score display
        const highScore = localStorage.getItem('nitroLaneRushHighScore') || 0;
        const highScoreText = this.add.text(400, 380, `High Score: ${highScore}`, { 
            fontSize: '16px', 
            fill: '#FFD700',
            fontStyle: 'bold'
        }).setOrigin(0.5);

        // Animated background elements
        this.createAnimatedBackground();
        
        this.game.canvas.setAttribute('tabindex', '0');
        this.game.canvas.focus();
        
        this.input.keyboard.once('keydown-SPACE', () => {
            this.startGameWithTransition();
        });
        this.input.on('pointerdown', () => {
            this.startGameWithTransition();
        });
    }

    createAnimatedBackground() {
        // Create moving road lines
        for (let i = 0; i < 5; i++) {
            const line = this.add.rectangle(150 + i * 130, -50, 4, 100, 0x444444);
            
            this.tweens.add({
                targets: line,
                y: 700,
                duration: 2000 + (i * 200),
                ease: 'Linear',
                repeat: -1,
                delay: i * 400
            });
        }

        // Create floating cars in background
        for (let i = 0; i < 3; i++) {
            const car = this.add.rectangle(200 + i * 200, 100 + i * 150, 30, 60, 0x333333, 0.3);
            
            this.tweens.add({
                targets: car,
                y: car.y + 20,
                duration: 1500,
                ease: 'Sine.easeInOut',
                yoyo: true,
                repeat: -1,
                delay: i * 500
            });
        }
    }

    startGameWithTransition() {
        // Fade out transition
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0);
        
        this.tweens.add({
            targets: overlay,
            alpha: 1,
            duration: 500,
            ease: 'Power2.easeIn',
            onComplete: () => {
                this.scene.start('GameScene');
            }
        });
    }
}

// SCENE 2: THE MAIN GAME WITH ENHANCED ANIMATIONS
class GameScene extends Phaser.Scene {
    constructor() {
        super('GameScene');
        this.playerSpeed = 300;
        this.isDragging = false;
        this.score = 0;
        this.roadSpeed = 4;
        this.enemySpeed = 150;
        this.spawnDelay = 1500;
        this.lives = 3;
        this.isInvincible = false;
        this.policeSpeed = 100;
        this.currentTrackIndex = 0;
        this.streak = 0;
        this.bestStreak = 0;
        this.lastObstacleHitTime = 0;
        
        // Performance optimization: Object pools
        this.enemyCarPool = [];
        this.policeCarPool = [];
        this.roadblockPool = [];
        this.maxPoolSize = 20;

        // Animation and effects
        this.particleEmitters = [];
        this.screenShakeIntensity = 0;
    }

    preload() {
        // Show loading text
        document.querySelector('.loading').style.display = 'block';
        
        // Load all image assets
        this.load.image('road', 'assets/road.png');
        this.load.image('player_car_hero', 'assets/player_car_hero.png');
        this.load.image('enemy_car_green', 'assets/enemy_car_green.png');
        this.load.image('enemy_car_yellow', 'assets/enemy_car_yellow.png');
        this.load.image('enemy_car_blue_sky', 'assets/enemy_car_blue_sky.png');
        this.load.image('enemy_car_police', 'assets/enemy_car_police.png');
        this.load.image('obstacle_roadblock_a', 'assets/obstacle_roadblock_a.png');

        // Load all four music tracks and the crash sound
        this.load.audio('music_1', 'assets/music_1.mp3');
        this.load.audio('music_2', 'assets/music_2.mp3');
        this.load.audio('music_3', 'assets/music_3.mp3');
        this.load.audio('music_4', 'assets/music_4.mp3');
        this.load.audio('sfx_crash', 'assets/crash.mp3');
        this.load.audio('sfx_powerup', 'assets/powerup.mp3'); // New power-up sound
        
        // Create particle texture for effects
        this.load.once('complete', () => {
            document.querySelector('.loading').style.display = 'none';
        });
    }

    create() {
        // Scene transition fade-in
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 1);
        this.tweens.add({
            targets: overlay,
            alpha: 0,
            duration: 500,
            ease: 'Power2.easeOut',
            onComplete: () => overlay.destroy()
        });

        // Road boundaries
        this.roadLeftBoundary = 120;
        this.roadRightBoundary = 680;
        this.intersectionYPositions = [150, 450];
        
        // Reset variables on scene start
        this.lives = 3;
        this.score = 0;
        this.streak = 0;
        this.bestStreak = 0;
        this.isInvincible = false;
        this.roadSpeed = 4;
        this.enemySpeed = 150;
        this.spawnDelay = 1500;
        this.policeSpeed = 100;
        this.currentTrackIndex = 0;
        this.lastObstacleHitTime = 0;

        // Create scrolling background
        this.road = this.add.tileSprite(400, 300, 800, 600, 'road');

        // Player Car with entrance animation
        this.car = this.physics.add.sprite(400, 700, 'player_car_hero');
        this.car.setCollideWorldBounds(true);
        this.car.body.setSize(45, 130);
        this.car.setInteractive();
        
        // Car entrance animation
        this.tweens.add({
            targets: this.car,
            y: 500,
            duration: 1000,
            ease: 'Back.easeOut'
        });
        
        // Optimized drag system
        this.input.setDraggable(this.car);
        this.input.on('dragstart', () => { 
            this.isDragging = true;
            // Scale up slightly when dragging
            this.tweens.add({
                targets: this.car,
                scaleX: 1.1,
                scaleY: 1.1,
                duration: 150,
                ease: 'Power2.easeOut'
            });
        });
        this.input.on('drag', (pointer, gameObject, dragX, dragY) => {
            const clampedX = Phaser.Math.Clamp(dragX, this.roadLeftBoundary, this.roadRightBoundary);
            const clampedY = Phaser.Math.Clamp(dragY, 50, 550);
            gameObject.setPosition(clampedX, clampedY);
        });
        this.input.on('dragend', () => { 
            this.isDragging = false;
            // Scale back to normal
            this.tweens.add({
                targets: this.car,
                scaleX: 1,
                scaleY: 1,
                duration: 150,
                ease: 'Power2.easeOut'
            });
        });
        
        // Sequential Playlist Logic
        this.sound.stopAll();
        this.musicPlaylist = ['music_1', 'music_2', 'music_3', 'music_4'];
        this.playNextTrack();

        // Initialize game objects
        this.enemyCars = this.physics.add.group();
        this.policeCars = this.physics.add.group();
        this.roadblocks = this.physics.add.group();
        this.powerUps = this.physics.add.group(); // New power-up group
        
        this.initializeObjectPools();
        
        this.spawnTimer = this.time.addEvent({ 
            delay: this.spawnDelay, 
            callback: this.spawnEnemyCar, 
            callbackScope: this, 
            loop: true 
        });
        this.policeSpawnTimer = this.time.addEvent({ 
            delay: 8000, 
            callback: this.spawnPoliceCar, 
            callbackScope: this, 
            loop: true 
        });
        this.roadblockSpawnTimer = this.time.addEvent({ 
            delay: 4000, 
            callback: this.spawnRoadblock, 
            callbackScope: this, 
            loop: true,
            paused: true 
        });
        this.powerUpSpawnTimer = this.time.addEvent({ // New power-up timer
            delay: 15000, 
            callback: this.spawnPowerUp, 
            callbackScope: this, 
            loop: true 
        });

        // Collision Handlers
        this.physics.add.overlap(this.car, this.enemyCars, this.hitEnemy, this.checkPreciseCollision, this);
        this.physics.add.overlap(this.car, this.policeCars, this.hitEnemy, this.checkPreciseCollision, this);
        this.physics.add.collider(this.policeCars, this.enemyCars);
        this.physics.add.collider(this.policeCars, this.policeCars);
        this.physics.add.overlap(this.car, this.roadblocks, this.hitRoadblock, this.checkPreciseCollision, this);
        this.physics.add.overlap(this.car, this.powerUps, this.collectPowerUp, null, this); // New power-up collision
        
        // UI with animations
        this.cursors = this.input.keyboard.createCursorKeys();
        this.scoreText = this.add.text(16, 16, 'Score: 0', { 
            fontSize: '32px', 
            fill: '#fff', 
            fontStyle: 'bold',
            stroke: '#000',
            strokeThickness: 2
        });
        this.livesText = this.add.text(620, 16, 'Lives: 3', { 
            fontSize: '32px', 
            fill: '#fff', 
            fontStyle: 'bold',
            stroke: '#000',
            strokeThickness: 2
        });
        this.streakText = this.add.text(16, 50, 'Streak: 0', { 
            fontSize: '24px', 
            fill: '#FFD700', 
            fontStyle: 'bold',
            stroke: '#000',
            strokeThickness: 1
        });

        // Animated UI entrance
        this.scoreText.setY(-50);
        this.livesText.setY(-50);
        this.streakText.setY(-50);
        this.tweens.add({
            targets: [this.scoreText, this.livesText, this.streakText],
            y: 16,
            duration: 800,
            ease: 'Bounce.easeOut',
            delay: 500
        });
        
        this.scoreTimer = this.time.addEvent({ 
            delay: 100, 
            callback: this.updateScore, 
            callbackScope: this, 
            loop: true 
        });

        // Create particle system for effects
        this.createParticleSystem();
    }

    createParticleSystem() {
        // Create particle texture programmatically if not loaded
        if (!this.textures.exists('particle')) {
            const particleGraphics = this.add.graphics();
            particleGraphics.fillStyle(0xFFFFFF);
            particleGraphics.fillCircle(2, 2, 2);
            particleGraphics.generateTexture('particle', 4, 4);
            particleGraphics.destroy();
        }
        
        // Exhaust particles from player car
        this.exhaustEmitter = this.add.particles(0, 0, 'particle', {
            speed: { min: 20, max: 40 },
            scale: { start: 0.3, end: 0 },
            alpha: { start: 0.6, end: 0 },
            lifespan: 300,
            frequency: 100,
            tint: 0x666666
        });
        this.exhaustEmitter.startFollow(this.car, 0, 30);
    }

    initializeObjectPools() {
        const carTypes = ['enemy_car_green', 'enemy_car_yellow', 'enemy_car_blue_sky'];
        
        // Pre-create enemy cars
        for (let i = 0; i < this.maxPoolSize; i++) {
            const carType = carTypes[i % carTypes.length];
            const car = this.physics.add.sprite(-100, -100, carType);
            car.setActive(false).setVisible(false);
            car.body.setSize(45, 100);
            this.enemyCarPool.push(car);
            this.enemyCars.add(car);
        }
        
        // Pre-create police cars
        for (let i = 0; i < 5; i++) {
            const car = this.physics.add.sprite(-100, -100, 'enemy_car_police');
            car.setActive(false).setVisible(false);
            car.body.setSize(50, 120);
            car.setData('isChasing', false);
            this.policeCarPool.push(car);
            this.policeCars.add(car);
        }
        
        // Pre-create roadblocks
        for (let i = 0; i < 10; i++) {
            const roadblock = this.physics.add.sprite(-100, -100, 'obstacle_roadblock_a');
            roadblock.setActive(false).setVisible(false);
            roadblock.setScale(2);
            roadblock.body.setSize(roadblock.width * 0.8, roadblock.height * 0.8);
            this.roadblockPool.push(roadblock);
            this.roadblocks.add(roadblock);
        }
        
        // Pre-create power-ups
        for (let i = 0; i < 5; i++) {
            const powerUp = this.physics.add.sprite(-100, -100, 'powerup_shield'); // Placeholder - we'll create it
            powerUp.setActive(false).setVisible(false);
            powerUp.setScale(1.5);
            this.powerUps.add(powerUp);
        }
    }

    playNextTrack() {
        if (this.currentTrackIndex >= this.musicPlaylist.length) {
            this.currentTrackIndex = 0;
        }
        const trackKey = this.musicPlaylist[this.currentTrackIndex];
        this.currentMusic = this.sound.add(trackKey, { volume: 0.5 });
        this.currentMusic.play();
        this.currentTrackIndex++;
        this.currentMusic.on('complete', this.playNextTrack, this);
    }

    checkPreciseCollision(player, object) {
        const playerBounds = player.getBounds();
        const objectBounds = object.getBounds();
        
        const overlapX = Math.max(0, Math.min(playerBounds.right, objectBounds.right) - Math.max(playerBounds.left, objectBounds.left));
        const overlapY = Math.max(0, Math.min(playerBounds.bottom, objectBounds.bottom) - Math.max(playerBounds.top, objectBounds.top));
        
        const minOverlapX = Math.min(playerBounds.width, objectBounds.width) * 0.25;
        const minOverlapY = Math.min(playerBounds.height, objectBounds.height) * 0.25;
        
        return overlapX >= minOverlapX && overlapY >= minOverlapY;
    }

    updateScore() {
        this.score += 1;
        this.scoreText.setText('Score: ' + this.score);
        
        // Animate score milestones
        if (this.score % 100 === 0) {
            this.tweens.add({
                targets: this.scoreText,
                scaleX: 1.2,
                scaleY: 1.2,
                duration: 150,
                ease: 'Power2.easeOut',
                yoyo: true
            });
        }
        
        if (this.score > 0 && this.score % 200 === 0 && this.spawnDelay > 600) {
            this.roadSpeed = Math.min(this.roadSpeed + 0.3, 8);
            this.enemySpeed = Math.min(this.enemySpeed + 15, 300);
            this.policeSpeed = Math.min(this.policeSpeed + 20, 200);
            this.spawnTimer.delay = Math.max(this.spawnTimer.delay * 0.96, 400);
            
            if (!this.roadblockSpawnTimer.paused && this.roadblockSpawnTimer.delay > 1500) {
                this.roadblockSpawnTimer.delay = Math.max(this.roadblockSpawnTimer.delay * 0.96, 1000);
            }

            // Speed increase notification
            const speedUpText = this.add.text(400, 300, 'SPEED UP!', {
                fontSize: '48px',
                fill: '#FF6600',
                fontStyle: 'bold',
                stroke: '#000',
                strokeThickness: 3
            }).setOrigin(0.5);

            this.tweens.add({
                targets: speedUpText,
                alpha: 0,
                y: 200,
                duration: 1500,
                ease: 'Power2.easeOut',
                onComplete: () => speedUpText.destroy()
            });
        }
        
        if (this.score >= 500 && this.roadblockSpawnTimer.paused) {
            this.roadblockSpawnTimer.paused = false;
            
            // Roadblock warning
            const warningText = this.add.text(400, 300, 'ROADBLOCKS AHEAD!', {
                fontSize: '36px',
                fill: '#FF0000',
                fontStyle: 'bold',
                stroke: '#000',
                strokeThickness: 3
            }).setOrigin(0.5);

            this.tweens.add({
                targets: warningText,
                alpha: 0,
                y: 200,
                duration: 2000,
                ease: 'Power2.easeOut',
                onComplete: () => warningText.destroy()
            });
        }
    }
    
    spawnRoadblock() {
        const roadblock = this.getFromPool(this.roadblockPool, (obj) => {
            const x = Phaser.Math.Between(this.roadLeftBoundary, this.roadRightBoundary);
            obj.setPosition(x, -50);
            obj.setScale(2);
            
            // Entrance animation
            obj.setAlpha(0);
            this.tweens.add({
                targets: obj,
                alpha: 1,
                duration: 300,
                ease: 'Power2.easeOut'
            });
        });
    }
    
    spawnPowerUp() {
        // Create power-up graphic if not exists
        if (!this.textures.exists('powerup_shield')) {
            const powerUpGraphics = this.add.graphics();
            powerUpGraphics.fillStyle(0x0066FF);
            powerUpGraphics.fillCircle(0, 0, 15);
            powerUpGraphics.fillStyle(0xFFFFFF);
            powerUpGraphics.fillCircle(0, 0, 10);
            powerUpGraphics.fillStyle(0x0066FF);
            powerUpGraphics.fillCircle(0, 0, 5);
            powerUpGraphics.generateTexture('powerup_shield', 30, 30);
            powerUpGraphics.destroy();
        }
        
        const x = Phaser.Math.Between(this.roadLeftBoundary + 20, this.roadRightBoundary - 20);
        const powerUp = this.powerUps.create(x, -50, 'powerup_shield');
        powerUp.setScale(1.5);
        powerUp.setVelocityY(100);
        
        // Add rotation animation
        this.tweens.add({
            targets: powerUp,
            angle: 360,
            duration: 2000,
            ease: 'Linear',
            repeat: -1
        });
        
        // Add floating effect
        this.tweens.add({
            targets: powerUp,
            y: powerUp.y + 20,
            duration: 1000,
            ease: 'Sine.easeInOut',
            yoyo: true,
            repeat: -1
        });
    }
    
    collectPowerUp(player, powerUp) {
        powerUp.destroy();
        this.sound.play('sfx_powerup');
        
        // Temporary invincibility
        if (!this.isInvincible) {
            this.isInvincible = true;
            
            // Visual effect
            const shield = this.add.circle(this.car.x, this.car.y, 40, 0x0066FF, 0.3);
            shield.setStrokeStyle(2, 0x00AAFF);
            
            this.tweens.add({
                targets: shield,
                alpha: 0,
                scaleX: 2,
                scaleY: 2,
                duration: 3000,
                ease: 'Power2.easeOut',
                onUpdate: () => {
                    shield.x = this.car.x;
                    shield.y = this.car.y;
                },
                onComplete: () => {
                    shield.destroy();
                    this.isInvincible = false;
                }
            });
        }
    }
    
    hitRoadblock(player, roadblock) {
        if (this.isInvincible) {
            this.returnToPool(roadblock);
            this.streak++;
            this.updateStreak();
            return;
        }
        
        this.sound.play('sfx_crash');
        this.createExplosionEffect(roadblock.x, roadblock.y);
        this.addScreenShake(8, 300);
        this.returnToPool(roadblock);
        this.resetStreak();
        this.gameOver();
    }

    spawnEnemyCar() {
        const enemyCar = this.getFromPool(this.enemyCarPool, (car) => {
            const x = Phaser.Math.Between(this.roadLeftBoundary, this.roadRightBoundary);
            car.setPosition(x, -50);
            car.setVelocityY(this.enemySpeed);
            car.setVelocityX(0);
            
            // Subtle entrance animation
            car.setScale(0.8);
            this.tweens.add({
                targets: car,
                scaleX: 1,
                scaleY: 1,
                duration: 200,
                ease: 'Power2.easeOut'
            });
        });
    }

    spawnPoliceCar() {
        const policeCar = this.getFromPool(this.policeCarPool, (car) => {
            const side = Phaser.Math.RND.pick(['left', 'right']);
            const yPos = Phaser.Math.RND.pick(this.intersectionYPositions);
            let startX, driveOnToX, mergeToX;
            
            if (side === 'left') { 
                startX = -50; 
                driveOnToX = 100; 
                mergeToX = this.roadLeftBoundary + 40; 
            } else { 
                startX = 850; 
                driveOnToX = 700; 
                mergeToX = this.roadRightBoundary - 40; 
            }
            
            car.setPosition(startX, yPos);
            car.setData('isChasing', false);
            
            // Police light flashing animation
            this.tweens.add({
                targets: car,
                alpha: 0.7,
                duration: 200,
                ease: 'Power1',
                yoyo: true,
                repeat: -1
            });
            
            this.tweens.add({
                targets: car, x: driveOnToX, duration: 800, ease: 'Power1',
                onComplete: () => {
                    this.tweens.add({
                        targets: car, x: mergeToX, y: car.y + 150, duration: 1000, ease: 'Power1',
                        onComplete: () => {
                            car.setData('isChasing', true);
                            car.setVelocityY(this.enemySpeed * 0.9);
                        }
                    });
                }
            });
        });
    }

    hitEnemy(player, enemyCar) {
        if (this.isInvincible) {
            this.returnToPool(enemyCar);
            this.streak++;
            this.updateStreak();
            return;
        }
        
        this.sound.play('sfx_crash');
        this.createExplosionEffect(enemyCar.x, enemyCar.y);
        this.addScreenShake(6, 250);
        this.returnToPool(enemyCar);
        this.resetStreak();
        
        this.lives--;
        this.livesText.setText('Lives: ' + this.lives);
        
        // Lives text animation
        this.tweens.add({
            targets: this.livesText,
            scaleX: 1.3,
            scaleY: 1.3,
            tint: 0xFF0000,
            duration: 200,
            ease: 'Power2.easeOut',
            yoyo: true,
            onComplete: () => {
                this.livesText.setTint(0xFFFFFF);
            }
        });
        
        if (this.lives <= 0) {
            this.gameOver();
        } else {
            // Enhanced invincibility animation
            this.isInvincible = true;
            this.tweens.add({
                targets: this.car, 
                alpha: 0.2, 
                duration: 100, 
                ease: 'Power1', 
                yoyo: true, 
                repeat: 12,
                onComplete: () => {
                    this.car.setAlpha(1);
                    this.isInvincible = false;
                }
            });
            
            // Add a protective glow effect
            const glow = this.add.circle(this.car.x, this.car.y, 30, 0x00FFFF, 0.3);
            this.tweens.add({
                targets: glow,
                scaleX: 1.5,
                scaleY: 1.5,
                alpha: 0,
                duration: 1300,
                ease: 'Power2.easeOut',
                onComplete: () => glow.destroy()
            });
            
            // Follow the car during invincibility
            this.tweens.add({
                targets: glow,
                x: this.car.x,
                y: this.car.y,
                duration: 1300,
                ease: 'Linear'
            });
        }
    }

    updateStreak() {
        this.streakText.setText('Streak: ' + this.streak);
        if (this.streak > this.bestStreak) {
            this.bestStreak = this.streak;
        }
        
        // Animate streak text when increasing
        this.tweens.add({
            targets: this.streakText,
            scaleX: 1.2,
            scaleY: 1.2,
            duration: 150,
            ease: 'Power2.easeOut',
            yoyo: true
        });
    }
    
    resetStreak() {
        this.streak = 0;
        this.streakText.setText('Streak: 0');
    }

    gameOver() {
        // Update high score
        const highScore = localStorage.getItem('nitroLaneRushHighScore') || 0;
        if (this.score > highScore) {
            localStorage.setItem('nitroLaneRushHighScore', this.score);
        }
        
        // Stop music
        if (this.currentMusic) { this.currentMusic.stop(); }
        
        // Stop exhaust particles
        this.exhaustEmitter.stop();
        
        // Dramatic game over effect
        this.addScreenShake(10, 500);
        
        // Car explosion
        this.createExplosionEffect(this.car.x, this.car.y);
        
        // Fade out car
        this.tweens.add({
            targets: this.car,
            alpha: 0,
            scale: 0.5,
            rotation: Math.PI,
            duration: 1000,
            ease: 'Power2.easeIn'
        });
        
        // Pause physics and timers
        this.physics.pause();
        this.spawnTimer.paused = true;
        this.policeSpawnTimer.paused = true;
        this.roadblockSpawnTimer.paused = true;
        this.powerUpSpawnTimer.paused = true;
        this.scoreTimer.paused = true;
        
        // Transition to game over screen
        this.time.delayedCall(1500, () => {
            const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0);
            this.tweens.add({
                targets: overlay,
                alpha: 1,
                duration: 1000,
                ease: 'Power2.easeIn',
                onComplete: () => {
                    this.scene.start('GameOverScene', { 
                        score: this.score,
                        bestStreak: this.bestStreak
                    });
                }
            });
        });
    }

    createExplosionEffect(x, y) {
        // Create particle texture if not exists
        if (!this.textures.exists('particle')) {
            const particleGraphics = this.add.graphics();
            particleGraphics.fillStyle(0xFFFFFF);
            particleGraphics.fillCircle(2, 2, 2);
            particleGraphics.generateTexture('particle', 4, 4);
            particleGraphics.destroy();
        }
        
        // Explosion particles
        const explosion = this.add.particles(x, y, 'particle', {
            speed: { min: 100, max: 300 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 500,
            quantity: 15,
            tint: [0xFF6600, 0xFF0000, 0xFFFF00]
        });
        
        this.time.delayedCall(500, () => explosion.destroy());
    }

    addScreenShake(intensity = 5, duration = 200) {
        this.screenShakeIntensity = intensity;
        
        this.tweens.add({
            targets: this.cameras.main,
            x: `+=${Phaser.Math.Between(-intensity, intensity)}`,
            y: `+=${Phaser.Math.Between(-intensity, intensity)}`,
            duration: 50,
            ease: 'Power2.easeInOut',
            yoyo: true,
            repeat: Math.floor(duration / 100),
            onComplete: () => {
                this.cameras.main.setPosition(0, 0);
                this.screenShakeIntensity = 0;
            }
        });
    }

    getFromPool(pool, resetCallback) {
        for (let obj of pool) {
            if (!obj.active) {
                obj.setActive(true).setVisible(true);
                resetCallback(obj);
                return obj;
            }
        }
        return null;
    }

    returnToPool(object) {
        object.setActive(false).setVisible(false);
        object.body.setVelocity(0, 0);
        object.body.setAcceleration(0, 0);
        object.setPosition(-100, -100);
        object.setScale(1); // Reset scale
        object.setAlpha(1); // Reset alpha
        if (object.texture.key === 'enemy_car_police') {
            object.setData('isChasing', false);
        }
    }

    update() {
        // Optimized road scrolling with slight variation
        this.road.tilePositionY -= this.roadSpeed + Math.sin(this.time.now * 0.001) * 0.2;
        
        // Enhanced player movement with smooth interpolation
        if (!this.isDragging) {
            this.car.body.setVelocity(0);
            
            const acceleration = this.playerSpeed * 1.2;
            if (this.cursors.left.isDown && this.car.x > this.roadLeftBoundary) { 
                this.car.body.setVelocityX(-acceleration);
                // Slight tilt when turning
                this.car.setRotation(-0.1);
            } else if (this.cursors.right.isDown && this.car.x < this.roadRightBoundary) { 
                this.car.body.setVelocityX(acceleration);
                this.car.setRotation(0.1);
            } else {
                // Return to center rotation
                this.car.setRotation(0);
            }
            
            if (this.cursors.up.isDown && this.car.y > 50) { 
                this.car.body.setVelocityY(-acceleration);
                // Increase exhaust when accelerating
                this.exhaustEmitter.setFrequency(50);
            } else if (this.cursors.down.isDown && this.car.y < 550) { 
                this.car.body.setVelocityY(acceleration);
                this.exhaustEmitter.setFrequency(150);
            } else {
                this.exhaustEmitter.setFrequency(100);
            }
        }

        // Performance: Optimized cleanup using object pools
        this.cleanupOffscreenObjects();
        
        // Optimized police AI with animations
        this.updatePoliceAI();
        
        // Update police car light animations
        this.updatePoliceEffects();
        
        // Update power-ups
        this.powerUps.children.entries.forEach(powerUp => {
            if (powerUp.active && powerUp.y > 650) {
                powerUp.destroy();
            }
        });
    }

    updatePoliceEffects() {
        this.policeCars.children.entries.forEach(policeCar => {
            if (policeCar.active && policeCar.getData('isChasing')) {
                // Emergency light effect - alternate between red and blue tint
                const time = this.time.now;
                const flashSpeed = 300;
                const isRed = Math.floor(time / flashSpeed) % 2 === 0;
                policeCar.setTint(isRed ? 0xFF4444 : 0x4444FF);
            }
        });
    }

    cleanupOffscreenObjects() {
        // Clean up enemy cars with exit animation
        this.enemyCars.children.entries.forEach(car => {
            if (car.active && car.y > 600) {
                // Quick fade out before returning to pool
                this.tweens.add({
                    targets: car,
                    alpha: 0,
                    duration: 100,
                    onComplete: () => this.returnToPool(car)
                });
            }
        });
        
        // Clean up police cars
        this.policeCars.children.entries.forEach(car => {
            if (car.active && car.y > 650) {
                this.returnToPool(car);
            }
        });
        
        // Clean up roadblocks
        this.roadblocks.children.entries.forEach(roadblock => {
            if (roadblock.active) {
                roadblock.y += this.roadSpeed;
                if (roadblock.y > 650) {
                    this.returnToPool(roadblock);
                }
            }
        });
    }

    updatePoliceAI() {
        this.policeCars.children.entries.forEach(policeCar => {
            if (policeCar.active && policeCar.getData('isChasing')) {
                const dx = this.car.x - policeCar.x;
                const targetSpeed = this.policeSpeed * 0.8;
                
                if (Math.abs(dx) > 15) {
                    const acceleration = dx > 0 ? targetSpeed : -targetSpeed;
                    policeCar.body.setAccelerationX(acceleration);
                    
                    // Add slight rotation when chasing
                    const targetRotation = dx > 0 ? 0.05 : -0.05;
                    policeCar.setRotation(targetRotation);
                } else {
                    policeCar.body.setAccelerationX(0);
                    policeCar.setRotation(0);
                }
            }
        });
    }
}

// SCENE 3: THE GAME OVER SCREEN WITH ANIMATIONS
class GameOverScene extends Phaser.Scene {
    constructor() {
        super('GameOverScene');
    }
    
    init(data) {
        this.finalScore = data.score;
        this.bestStreak = data.bestStreak || 0;
    }
    
    create() {
        // Fade in from black
        const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 1);
        this.tweens.add({
            targets: overlay,
            alpha: 0,
            duration: 1000,
            ease: 'Power2.easeOut',
            onComplete: () => overlay.destroy()
        });

        // Animated game over title
        const gameOverText = this.add.text(400, 150, 'GAME OVER', { 
            fontSize: '64px', 
            fill: '#ff0000', 
            fontStyle: 'bold',
            stroke: '#000',
            strokeThickness: 4
        }).setOrigin(0.5);
        
        // Game over title animation
        gameOverText.setScale(0);
        this.tweens.add({
            targets: gameOverText,
            scale: 1,
            duration: 800,
            ease: 'Back.easeOut',
            delay: 500
        });

        // Pulsing effect on game over text
        this.tweens.add({
            targets: gameOverText,
            alpha: 0.7,
            duration: 1000,
            ease: 'Sine.easeInOut',
            yoyo: true,
            repeat: -1,
            delay: 1300
        });
        
        // Score display with typewriter effect
        const scoreDisplay = this.add.text(400, 250, '', { 
            fontSize: '32px', 
            fill: '#fff',
            stroke: '#000',
            strokeThickness: 2
        }).setOrigin(0.5);
        
        // Typewriter effect for score
        const scoreText = `Your Score: ${this.finalScore}`;
        let currentChar = 0;
        
        this.time.addEvent({
            delay: 50,
            callback: () => {
                if (currentChar <= scoreText.length) {
                    scoreDisplay.setText(scoreText.substring(0, currentChar));
                    currentChar++;
                }
            },
            repeat: scoreText.length,
            callbackScope: this,
            startAt: 1200
        });

        // Best streak display
        const streakText = this.add.text(400, 290, `Best Streak: ${this.bestStreak}`, { 
            fontSize: '24px', 
            fill: '#FFD700',
            stroke: '#000',
            strokeThickness: 2
        }).setOrigin(0.5);
        
        // High score display
        const highScore = localStorage.getItem('nitroLaneRushHighScore') || 0;
        const isNewHighScore = this.finalScore >= highScore;
        const highScoreText = this.add.text(400, 320, `High Score: ${highScore}`, { 
            fontSize: '24px', 
            fill: isNewHighScore ? '#FFD700' : '#00FF88',
            stroke: '#000',
            strokeThickness: 2
        }).setOrigin(0.5);
        
        if (isNewHighScore) {
            // Animate new high score
            this.tweens.add({
                targets: highScoreText,
                scaleX: 1.2,
                scaleY: 1.2,
                duration: 300,
                ease: 'Power2.easeOut',
                yoyo: true,
                repeat: 3
            });
        }

        // Performance rating based on score
        let rating = 'Rookie Driver';
        let ratingColor = '#CCCCCC';
        
        if (this.finalScore >= 2000) {
            rating = 'Speed Demon!';
            ratingColor = '#FFD700';
        } else if (this.finalScore >= 1500) {
            rating = 'Racing Pro';
            ratingColor = '#FF6600';
        } else if (this.finalScore >= 1000) {
            rating = 'Street Racer';
            ratingColor = '#00FF88';
        } else if (this.finalScore >= 500) {
            rating = 'Skilled Driver';
            ratingColor = '#00AAFF';
        }

        const ratingText = this.add.text(400, 360, rating, {
            fontSize: '24px',
            fill: ratingColor,
            fontStyle: 'bold',
            stroke: '#000',
            strokeThickness: 2
        }).setOrigin(0.5);

        // Rating animation
        ratingText.setY(400);
        this.tweens.add({
            targets: ratingText,
            y: 360,
            duration: 600,
            ease: 'Bounce.easeOut',
            delay: 2000
        });
        
        // Restart instruction with bouncing animation
        const restartText = this.add.text(400, 450, 'Tap or Press SPACE to Restart', { 
            fontSize: '24px', 
            fill: '#fff',
            stroke: '#000',
            strokeThickness: 2
        }).setOrigin(0.5);
        
        this.tweens.add({
            targets: restartText,
            y: restartText.y - 10,
            duration: 1000,
            ease: 'Sine.easeInOut',
            yoyo: true,
            repeat: -1,
            delay: 2500
        });

        // Animated background elements
        this.createAnimatedBackground();
        
        // Input handlers with transition effect
        this.input.keyboard.once('keydown-SPACE', () => {
            this.restartWithTransition();
        });
        this.input.on('pointerdown', () => {
            this.restartWithTransition();
        });
    }

    createAnimatedBackground() {
        // Create floating debris/spark effects
        for (let i = 0; i < 10; i++) {
            const debris = this.add.circle(
                Phaser.Math.Between(0, 800), 
                Phaser.Math.Between(0, 600), 
                Phaser.Math.Between(2, 6), 
                0x666666, 
                0.3
            );
            
            this.tweens.add({
                targets: debris,
                x: debris.x + Phaser.Math.Between(-100, 100),
                y: debris.y + Phaser.Math.Between(-100, 100),
                alpha: 0,
                duration: Phaser.Math.Between(3000, 6000),
                ease: 'Power2.easeOut',
                delay: Phaser.Math.Between(0, 2000),
                onComplete: () => debris.destroy()
            });
        }

        // Scrolling road effect in background
        const bgRoad = this.add.tileSprite(400, 300, 800, 600, 'road');
        bgRoad.setAlpha(0.2);
        
        this.tweens.add({
            targets: bgRoad,
            tilePositionY: 600,
            duration: 8000,
            ease: 'Linear',
            repeat: -1
        });
    }

    restartWithTransition() {
        // Zoom in transition effect
        this.tweens.add({
            targets: this.cameras.main,
            zoom: 2,
            duration: 500,
            ease: 'Power2.easeIn',
            onComplete: () => {
                this.scene.start('GameScene');
            }
        });
        
        // Flash effect
        const flash = this.add.rectangle(400, 300, 800, 600, 0xFFFFFF, 0);
        this.tweens.add({
            targets: flash,
            alpha: 1,
            duration: 100,
            ease: 'Power2.easeOut',
            yoyo: true
        });
    }
}

// THE GAME CONFIGURATION
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    backgroundColor: '#222',
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false,
            fps: 60,
            fixedStep: false
        }
    },
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    render: {
        antialias: false,
        pixelArt: false,
        roundPixels: true
    },
    scene: [StartScene, GameScene, GameOverScene]
};

// Create the game instance
window.addEventListener('load', () => {
    new Phaser.Game(config);
});
</script>
</body>
</html>
